#include<iostream>
using namespace std;

/*
一是释放最初申请的那部分空间，二是调用析构函数完成清理工作。对于内存空间的清理，由于申请时记录了其大小，
因此无论使用delete还是delete[ ]都能将这片空间完整释放，而问题就出在析构函数的调用上，
当使用delete时，仅仅调用了对象数组中第一个对象的析构函数，而使用delete [ ]的话，将会逐个调用析构函数。
*/

/*
1.  如果你的派生类内部没有分配任何堆,而只是单一的局部变量,那么根据局部变量和类的生命周期理论，
他们是会被释放的,“不会对程序有直接影响
2.  如果你的派生类内部有分配堆,那么派生类就没法通过自身的析构函数进行尾场清理了
*/
class A
{
public:
    A(){}
    ~A(){cout<<"Destruct"<<endl;}
};
class B:public A
{
public:
    B(){}
    ~B(){}
};

int main()
{
    A* pa=new B;//不同于 B b;这里new不会调用析构函数
    delete pa;
}